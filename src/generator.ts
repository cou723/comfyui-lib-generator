import { ensureDir } from "jsr:@std/fs@1/ensure-dir";
import { join } from "jsr:@std/path@1/join";

type RawInputSpec = [string | string[], Record<string, unknown>?];

type NodeInfo = {
  input?: Record<string, Record<string, RawInputSpec>>;
  input_order?: Record<string, string[]>;
  output?: string[];
  output_name?: string[];
  name: string;
};

type ProcessedInput = {
  name: string;
  key: string;
  initializer: string;
};

type ProcessedOutput = {
  name: string;
  kind: string;
  index: number;
};

type ProcessedNode = {
  typeName: string;
  exportName: string;
  inputs: ProcessedInput[];
  outputs: ProcessedOutput[];
};

export type GenerateOptions = {
  objectInfoPath: string;
  libraryRoot: string;
};

const NUMBER_TYPES = new Set(["INT", "FLOAT", "NUMBER"]);
const BOOLEAN_TYPES = new Set(["BOOLEAN"]);
const STRING_TYPES = new Set(["STRING", "PRIMITIVE", "COMBO", "MULTI_COMBO"]);
const IGNORED_INPUT_SECTIONS = new Set(["hidden"]);

export async function generateLibrary(options: GenerateOptions) {
  const { objectInfoPath, libraryRoot } = options;
  const objectInfoRaw = await Deno.readTextFile(objectInfoPath);
  const nodeInfos = JSON.parse(objectInfoRaw) as Record<string, NodeInfo>;

  const generatedDir = join(libraryRoot, "generated");
  await ensureDir(generatedDir);

  const nodesPath = join(generatedDir, "nodes.gen.ts");
  const registryPath = join(generatedDir, "registry.gen.ts");
  const kindsPath = join(generatedDir, "kinds.gen.ts");

  const kindSet = collectKinds(nodeInfos);
  const kinds = Array.from(kindSet).sort();
  const processedNodes = prepareNodes(nodeInfos);

  await Promise.all([
    writeKindsFile(kindsPath, kinds),
    writeNodesFile(nodesPath, processedNodes),
    writeRegistryFile(registryPath, processedNodes),
  ]);
}

function collectKinds(infos: Record<string, NodeInfo>): Set<string> {
  const kinds = new Set<string>();
  for (const info of Object.values(infos)) {
    for (const kind of info.output ?? []) {
      if (typeof kind === "string") kinds.add(kind);
    }
    const sections = info.input ?? {};
    for (const [sectionName, section] of Object.entries(sections)) {
      if (IGNORED_INPUT_SECTIONS.has(sectionName)) continue;
      for (const spec of Object.values(section ?? {})) {
        if (!Array.isArray(spec)) continue;
        const typeOrChoices = spec[0];
        if (typeof typeOrChoices === "string") {
          kinds.add(typeOrChoices);
        }
      }
    }
  }
  return kinds;
}

async function writeKindsFile(path: string, kinds: string[]) {
  const items = kinds.map((kind) => `  "${kind}"`).join(",\n");
  const content = `// Auto-generated by comfyui-lib-generator; DO NOT EDIT.
export const generatedKinds = [
${items}
] as const;

export type GeneratedKind = (typeof generatedKinds)[number];
`;
  await Deno.writeTextFile(path, content);
}

async function writeNodesFile(path: string, nodes: ProcessedNode[]) {
  const helperImports = new Set<string>(["defineNode"]);
  for (const node of nodes) {
    for (const input of node.inputs) {
      if (input.initializer.startsWith("numberInput")) {
        helperImports.add("numberInput");
      } else if (input.initializer.startsWith("stringInput")) {
        helperImports.add("stringInput");
      } else if (input.initializer.startsWith("booleanInput")) {
        helperImports.add("booleanInput");
      } else if (input.initializer.startsWith("connectionInput")) {
        helperImports.add("connectionInput");
      }
    }
  }

  const importList = Array.from(helperImports).sort().join(",\n  ");
  const lines: string[] = [
    "// Auto-generated by comfyui-lib-generator; DO NOT EDIT.",
    "import {",
    `  ${importList},`,
    '} from "../core/types.ts";',
    "",
  ];

  for (const node of nodes) {
    lines.push(renderNode(node));
  }

  lines.push("export const nodes = {");
  for (const node of nodes) {
    lines.push(`  ["${node.typeName}"]: ${node.exportName},`);
  }
  lines.push("} as const;", "");

  await Deno.writeTextFile(path, lines.join("\n"));
}

async function writeRegistryFile(path: string, nodes: ProcessedNode[]) {
  const entries = nodes.map((node) =>
    `  [N.${node.exportName}.type]: N.${node.exportName},`
  ).join("\n");
  const content = `// Auto-generated by comfyui-lib-generator; DO NOT EDIT.
import { AnyNodeDef } from "../core/types.ts";
import * as N from "./nodes.gen.ts";

export const registry: Record<string, AnyNodeDef> = {
${entries}
};
`;
  await Deno.writeTextFile(path, content);
}

function prepareNodes(infos: Record<string, NodeInfo>): ProcessedNode[] {
  const usedNames = new Set<string>();
  const nodes: ProcessedNode[] = [];

  for (const [typeName, info] of Object.entries(infos)) {
    if (hasComboOutputs(info)) {
      console.warn(`Skipping ${typeName}: combo outputs are not supported yet`);
      continue;
    }
    nodes.push({
      typeName,
      exportName: makeExportName(typeName, usedNames),
      inputs: buildInputs(info),
      outputs: buildOutputs(info),
    });
  }

  nodes.sort((a, b) => a.typeName.localeCompare(b.typeName));
  return nodes;
}

function buildInputs(info: NodeInfo): ProcessedInput[] {
  const inputs: ProcessedInput[] = [];
  const sections = info.input ?? {};
  const sectionOrder = info.input_order ?? {};

  for (const [sectionName, section] of Object.entries(sections)) {
    if (IGNORED_INPUT_SECTIONS.has(sectionName)) continue;
    if (!section) continue;
    const orderedNames = sectionOrder[sectionName] ?? Object.keys(section);
    for (const name of orderedNames) {
      const spec = section[name];
      if (!spec) continue;
      const initializer = buildInputInitializer(spec, sectionName === "required");
      if (!initializer) continue;
      inputs.push({ name, key: formatPropertyKey(name), initializer });
    }
  }

  return inputs;
}

function buildOutputs(info: NodeInfo): ProcessedOutput[] {
  const result: ProcessedOutput[] = [];
  const kinds = (info.output ?? []) as string[];
  const names = info.output_name ?? [];
  const usedNames = new Set<string>();

  kinds.forEach((kind, index) => {
    const rawName = names[index] ?? `${index}`;
    const baseName = formatIdentifier(rawName) || `output${index}`;
    let finalName = baseName;
    let suffix = 1;
    while (usedNames.has(finalName)) {
      finalName = `${baseName}${suffix++}`;
    }
    usedNames.add(finalName);
    result.push({ name: finalName, kind, index });
  });

  return result;
}

function buildInputInitializer(
  spec: RawInputSpec,
  requiredSection: boolean,
): string | null {
  if (!Array.isArray(spec)) return null;
  const [typeOrChoices, options = {}] = spec;
  const defaultValue = options["default"];
  const hasDefault = defaultValue !== undefined;
  const required = requiredSection && !hasDefault;

  if (Array.isArray(typeOrChoices)) {
    if (shouldEmitEnum(typeOrChoices)) {
      return `stringInput({${renderOptions(required, {
        enumValues: typeOrChoices as string[],
        defaultValue,
        expectedType: "string",
      })}})`;
    }
    return `stringInput({${renderOptions(required, { defaultValue, expectedType: "string" })}})`;
  }

  if (typeof typeOrChoices !== "string") {
    return null;
  }

  if (isConnectionType(typeOrChoices)) {
    return `connectionInput({${renderOptions(required, {
      kind: typeOrChoices,
      defaultValue,
      expectedType: "connection",
    })}})`;
  }

  if (NUMBER_TYPES.has(typeOrChoices)) {
    return `numberInput({${renderOptions(required, { defaultValue, expectedType: "number" })}})`;
  }

  if (BOOLEAN_TYPES.has(typeOrChoices)) {
    return `booleanInput({${renderOptions(required, { defaultValue, expectedType: "boolean" })}})`;
  }

  if (STRING_TYPES.has(typeOrChoices)) {
    return `stringInput({${renderOptions(required, { defaultValue, expectedType: "string" })}})`;
  }

  return `stringInput({${renderOptions(required, { defaultValue, expectedType: "string" })}})`;
}

function renderOptions(
  required: boolean,
  opts: {
    kind?: string;
    defaultValue?: unknown;
    enumValues?: string[];
    expectedType?: "number" | "string" | "boolean" | "connection";
  },
): string {
  const pieces = [`required: ${required}`];
  if (opts.kind) {
    pieces.push(`kind: "${opts.kind}"`);
  }
  if (opts.enumValues) {
    pieces.push(`enum: ${JSON.stringify(opts.enumValues)} as const`);
  }
  const dv = opts.defaultValue;
  const et = opts.expectedType;
  const okDefault = !required && dv !== undefined && (
    (et === "number" && typeof dv === "number") ||
    (et === "boolean" && typeof dv === "boolean") ||
    (et === "string" && typeof dv === "string")
  );
  if (okDefault) {
    pieces.push(`default: ${JSON.stringify(dv)}`);
  }
  return ` ${pieces.join(", ")} `;
}

function renderNode(node: ProcessedNode): string {
  const lines = [
    `export const ${node.exportName} = defineNode({`,
    `  type: "${node.typeName}",`,
  ];

  if (node.inputs.length === 0) {
    lines.push("  inputs: {},");
  } else {
    lines.push("  inputs: {");
    for (const input of node.inputs) {
      lines.push(`    ${input.key}: ${input.initializer},`);
    }
    lines.push("  },");
  }

  if (node.outputs.length === 0) {
    lines.push("  outputs: {},");
  } else {
    lines.push("  outputs: {");
    for (const output of node.outputs) {
      lines.push(`    ${output.name}: { kind: "${output.kind}", index: ${output.index} },`);
    }
    lines.push("  },");
  }

  lines.push("});", "");
  return lines.join("\n");
}

function makeExportName(value: string, used: Set<string>): string {
  const words = value
    .replace(/[^a-zA-Z0-9]+/g, " ")
    .trim()
    .split(/\s+/)
    .filter(Boolean)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1));
  let candidate = words.join("").replace(/^[^a-zA-Z_]+/, "");
  if (!candidate) candidate = "Node";
  let unique = candidate;
  let suffix = 2;
  while (used.has(unique)) {
    unique = `${candidate}${suffix++}`;
  }
  used.add(unique);
  return unique;
}

function formatIdentifier(value: string | undefined): string {
  if (!value) return "";
  const words = value
    .replace(/[^a-zA-Z0-9]+/g, " ")
    .trim()
    .split(/\s+/)
    .filter(Boolean)
    .map((word) => word.toLowerCase());

  if (words.length === 0) return "";
  const [first, ...rest] = words;
  const camel = first + rest.map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join("");
  return camel.replace(/^[^a-zA-Z_]+/, "");
}

function formatPropertyKey(name: string): string {
  if (/^[A-Za-z_][A-Za-z0-9_]*$/.test(name)) return name;
  return JSON.stringify(name);
}

function shouldEmitEnum(values: unknown[]): values is string[] {
  if (values.length === 0 || values.length > 64) return false;
  return values.every((value) =>
    typeof value === "string" && value.length > 0 && !/[\\/]/.test(value)
  );
}

function isConnectionType(type: string): boolean {
  if (!type) return false;
  if (NUMBER_TYPES.has(type)) return false;
  if (BOOLEAN_TYPES.has(type)) return false;
  if (STRING_TYPES.has(type)) return false;
  return true;
}

function hasComboOutputs(info: NodeInfo): boolean {
  return (info.output ?? []).some((kind) => Array.isArray(kind));
}

function isPrimitiveDefault(value: unknown): value is string | number | boolean | null {
  return (
    value === null ||
    typeof value === "string" ||
    typeof value === "number" ||
    typeof value === "boolean"
  );
}
